var axios = require('axios');
var typearray = ['cry', 'cuddle', 'hug', 'kiss', 'lewd', 'lick', 'nom', 'nyan', 'owo', 'pat', 'pout', 'rem', 'slap', 'smug', 'stare', 'tickle', 'triggered', 'nsfw-gtn', 'potato', 'kermit'] //An array for the available types for v1

class WolkeAPI {
    
    constructor({version, nsfw}) {
        if (!version || isNaN(version) || version !== 1 && version !== 2) {
            version = 1; //This is the latest version of the API, will be changed to 2 soon
        }
        if (nsfw !== true) {
            nsfw = false;
        }
        if (version == 1) { this.api = "https://rra.ram.moe"; this.cdn = "https://cdn.ram.moe";}
        if (version == 2) { this.api = "https://staging-api.ram.moe"; this.cdn = "https://staging-cdn.ram.moe";}
        this.version = version;
        this.nsfw = nsfw;
    }

    types() {
        if (this.version == 1) {
            return new Promise((resolve, reject) => {
            resolve(typearray);
            return typearray;
        }); 
        }
        if (this.version == 2) {
           return new Promise((resolve, reject) => {
            axios.get(`${this.api}/images/types`).then(res => {
                if (res.data) {
                    if (res.data.status === 200) {
                        resolve(res.data.types);
                        return res.data.types;
                    } else {
                        reject("Error " + res.data.status + ": " + res.data.message);
                    }
                } else {
                  reject("Unknown error: API returned an error response.");  
                }
            }).catch(err => {
                reject(err);
            });
        }); 
        }           
    }
    
    tags() {
        if (this.version == 1) {
               return new Promise((resolve, reject) => {
            reject("Error 1: This function is not available in API v1.");
        }); 
        }
        if (this.version == 2) {
           return new Promise((resolve, reject) => {
            axios.get(`${this.api}/images/tags`).then(res => {
                if (res.data) {
                    if (res.data.status === 200) {
                        resolve(res.data.tags);
                        return res.data.tags;
                    } else {
                        reject("Error " + res.data.status + ": " + res.data.message);
                    }
                } else {
                  reject("Unknown error: API returned an error response.");  
                }
            }).catch(err => {
                reject(err);
            });
        }); 
        }           
    }
    
    pictureInfo(id) {
        if (this.version == 1) {
          return new Promise((resolve, reject) => {
            axios.get(`${this.api}/i/${id}`).then(res => {
                if (res) {
                    if (res.status === 200) {
                        var json = JSON.parse("{\"url\": \"" + this.api + "/i/" + id + "\", \"isFound\": true}")
                        resolve(json);
                        return json;
                    } else {
                        var json = JSON.parse("{\"url\": null, \"isFound\": false}")
                        resolve(json);
                        return json;
                    }
                } else {
                  reject("Unknown error: API returned an error response.");  
                }
            }).catch(err => {
                reject(err);
            });
        }); 
        }
        if (this.version == 2) {
           return new Promise((resolve, reject) => {
            axios.get(`${this.api}/images/info/${id}`).then(res => {
                if (res) {
                    if (res.status === 200) {
                        var json = JSON.parse("{\"url\": \"" + this.api + "/i/" + id + "\", \"isFound\": true}")
                        resolve(json);
                        return json;
                    } else {
                        var json = JSON.parse("{\"url\": null, \"isFound\": false}")
                        resolve(json);
                        return json;
                    }
                } else {
                  reject("Unknown error: API returned an error response.");  
                }
            }).catch(err => {
                reject(err);
            });
        });           
    }
    }
    
    picture(type, tags) {
        if (this.version == 1) {
            if (!type) {
               return new Promise((resolve, reject) => {
            reject("Error 1: Missing parameter: Type");
        }); 
            }
            if (type === 'nsfw-gtn' && this.nsfw === false) {
                return new Promise((resolve, reject) => {
            reject("Error 1: NSFW is not enabled for this type.");
        }); 
            }
            if (tags) {
                tags = null; //v1 don't support tags
            }
        return new Promise((resolve, reject) => {
            axios.get(`${this.api}/i/r?type=${type !== null ? type : ''}&nsfw=${this.nsfw !== false ? 'true' : 'false'}`).then(res => {
                if (res.data) {
                    if (!res.data.error) {
                        var json = JSON.parse("{\"url\": \"" + this.cdn + res.data.path.replace("i/", "") + "\"}")
                        resolve(json);
                        return json;
                    } else {
                        reject("Error " + res.data.error + ": " + res.data.message);
                    }
                } else {
                  reject("Unknown error: API returned an error response.");   
                }
            }).catch(err => {
                reject(err);
            });
        });
        }
        if (this.version == 2) {
            if (!type && !tags) {
               return new Promise((resolve, reject) => {
            reject("Error 1: Missing parameters");
        }); 
            }
        return new Promise((resolve, reject) => {
            axios.get(`${this.api}/images/random?type=${type !== null ? type : ''}&tags=${tags ? tags.join(",") : ''}&nsfw=${this.nsfw !== false ? 'true' : 'false'}`).then(res => {
                if (res.data) {
                    if (res.data.status === 200) {
                        resolve(res.data);
                        return res.data;
                    } else {
                        reject("Error " + res.data.status + ": " + res.data.message);
                    }
                } else {
                  reject("Unknown error: API returned an error response.");  
                }
            }).catch(err => {
                reject(err);
            });
        });
        }
    }  
    
}
    
module.exports = WolkeAPI;